# C和指针
## 快速上手
### 注释
>通过使用缩进和注释使代码易读。

>注释代码使用/**/可能无效，可以使用：
```c
#if 0
    statements
#endif
```

### 预处理指令
>将几个声明写在一个单独的文件中，然后用预处理执行引入，有利于维护。

>C语言中，所有传递给函数的参数都是按值传递的。因为数组名是数组首元素地址，所以数组名作为函数参数时传递的是指针，就会产生按引用传递的效果。

>使用所有格式码(除了%c外)时，输入值之前的空白(空格、制表符、换行符等)会被跳过，值后面的空白表示该值的结束。

>标准未规定编译器对数组下标有效性进行检查，所以需要在程序中自行检查。

>const修饰的数组名作为函数参数时的作用：可以防止此数组内的元素在函数内被修改。

## 基本概念
>ANSI C中，存在两种不同的环境：
- 翻译环境 用于将源代码被转换为可执行的机器指令
- 执行环境 用于实际执行代码

>交叉编译器

>独立环境

### 翻译
>翻译阶段由几个步骤组成：
- 将组成程序的每个源代码通过<em>编译</em>分别转换为<em>目标代码</em>
    * 预处理器处理阶段 预处理器在源代码上执行一些文本操作，如：用实际值代替由#define指令定义的符号以及读入由#include指令包含的文件的内容
    * 对源代码进行解析，判断语句含义。在此过程中生成警告和错误信息。
    * 生成目标代码(机器指令的初步形式)。优化器会处理优化选项，提高代码效率。
- 各个目标文件由<em>链接器</em>链接在一起，形成一个单一而完整的可执行程序。链接器会在用户目录和库目录中查找引用的函数(包括库函数和个人程序库函数)，并将引用的函数链接到程序。
  

### 文件名约定
>源文件通常以.c为扩展名，头文件通常以.h为扩展名；在unix系统中，目标文件扩展名是.o，在MS_DOC系统中则是.obj.

### 编译和链接
>在大部分UNIX系统中，C编译器被称为cc,它可以通过以下方式调用：
- 编译并链接一个完全包含于一个源文件的C程序：
  ```sh
  cc program.c
  ```
  上述命令产生一个称为a.out的可执行程序，中间会产生一个名为program.o的目标文件，但它在链接过程完成后会被删除。
- 编译并链接几个C源文件：
  ```sh
  cc main.c sort.c lookup.c
  ```
  当编译的源文件超过一个时，目标文件不会被删除，所以允许在对程序修改后，只对改动过的源文件进行重新编译。如下所示：
- 编译一个C源文件，并把它和现存的目标文件链接在一起：
  ```sh
  cc mian.o lookup.o sort.c
  ```
- 编译单个C源文件，并产生一个目标文件，以后再进行链接：
  ```sh
  cc -c program.c
  ```
- 编译几个C源文件，并为每个文件产生一个目标文件：
  ```sh
  cc -c main.c sort.c lookup.c
  ```
- 链接几个目标文件：
  ```sh
  cc main.o sort.o lookpu.o
  ```

>注：以上生成可执行文件的命令均可加上"-o name"选项，用于指定生成的可执行文件的名称。

>默认情况下，链接器在标准C函数库中查找函数；若在编译时在命令最后加上"-lname"标志，则链接器会同时在"name"的函数库中查找。

>在MS-DOS命令行界面下，与UNIX编译器有以下不同：
- 名字是 bcc
- 目标文件的名字是file.obj
- 当单个源文件被编译并链接时，编译器不删除目标文件
- 在缺省情况下，可执行文件以命令行中第一个源或目标文件名命名，可以使用"-ename"选项指定目标文件名。

### 执行
>程序执行过程需要经历几个阶段：
- 程序载入内存
- 执行开始 收集命令行参数，开始调用main函数
- 开始执行程序代码  在大多数机器中，程序使用一个运行时堆栈存储函数的局部变量和返回地址。用静态内存存储静态变量。
- 程序终止。

### 词法规则
>ANSI C程序 =  声明 + 函数；函数用于定义需要执行的工作，而声明则描述了函数将要操作的数据类型。

>三字母词：几个字符的序列合起来表示一个字符。如：??( 表示[等。偶尔在代码中输出三字母组合时，会被替换为它所代表的单字符。

>转义序列/字符转义：\?（用于在连续书写??时避免三字母词）    \" \' \\

### 代码风格
>建议代码风格：
- 空行用于分隔不同逻辑的代码。
- 操作符前后空格。
- 使用Tab而不是空格缩进。
- 注释成块出现。
- 函数定义中，返回类型独立一行。
- 空循环，;独立一行，有助于清晰看到是空循环。

## 数据
>数据有四个属性：
- 类型
- 作用域
- 连接属性
- 存储类型

>类型决定了变量的存储方式和读取方式，在内存中占用空间大小和传递以及处理方式。

>作用域、链接属性、存储类型决定了变量的可见性和生命周期。

### 基本数据类型
>C中有四种基本数据类型：
- 整型
- 浮点型
- 指针类型
- 聚合类型(数组和结构体、共用体等)

#### 整型
>整型包括四种类型：
- 字符类型
- 短整型
- 整型
- 长整型

>注：以上四种均分为有符号和无符号两类。

>头文件 limits.h 说明了不同整数类型的特点。

>如果一个多字节字符常量的前面有一个L，则它就是宽字符常量。如 L'X' L'e^'

##### 枚举类型
```c
enum Jar_Type{CPU=8,PINT=16,QUART=32,HALF_GALLON=64,GALLON=128}
```
### 浮点类型
>浮点类型包括：
- float
- double
- long double

>注：头文件 float.h 说明了不同浮点类型的特点。


### 指针
#### 字符串常量
>C语言中没有字符串类型，但提供了字符串常量。C语言中字符串是指：一串以NUL字节结尾的零个或多个字符。

>不要修改字符串常量，很危险；如果需要修改，把它存储于数组中。

>可以把字符串常量赋给一个"指向字符的指针"，但是不能把字符串常量赋给一个字符数组，因为字符串常量的直接值是一个指针，而不是字符串本身。

>除char类型外，其他整型类型的默认类型均为singed;而char 默认类型具体是何种，因编译器而异。

>在声明整型变量时，如果声明中已经至少有一个其他的说明符，关键字int可以省略：
```c
//以下声明等效
unsigned short int     a;
unsigned short         a;
```

>在进行指针变量声明时，采用格式：
```c
/* 不要将* 放在int旁边是因为如下形式中，c,d是int型白能量，而只有b是int型指针变量，所以把*放在变量一侧更清晰，也不致引起误解 */
// int* b,c,d;
int *b,c,d;         /* 采用此种形式更清晰 */
char *messaage = "Hello world!";
```

#### 隐式声明
>有几种声明，它的类型名可以省略，比如函数如果不显式地声明返回值类型，它就默认返回整型。避免使用隐式声明。

#### typedef
>typedef 允许为各种数据类型定义新名字,写法是在普通声明前加上typedef：
```c
char    *ptr_to_char;
typedef char    *ptr_to_char;   /* 把标志符ptr_to_char作为指向字符的指向类型的新名称 */
ptr_to_char     a;              /* 声明指向char类型的指针变量a */
```

>使用typedef可以避免声明太长太复杂；也可以增加程序移植时的灵活性。

>使用typedef而不是#define来创建新的类型名，因为#define无法处理指针类型，如下：
```c
#define d_ptr_to_char char*
d_ptr_to_char a, b;             /* b被声明为一个字符 */
```

### 常量
>常量与变量声明完全一致，区别在于常量值不能修改：
```c
int     const       a;
const   int         a;
```
>在函数中声明为const的形参在函数被调用时会得到实参的值。

>当const修改指针变量时，请参见程序：<em>const_pointer_param_test.c</em>:
```c
/*
** 此程序用于测试const关键字特性
**
** 如下三种形式的指针常量作为函数形参时，测试结果如下：
** 1.int const*p						可改变指针变量值，但不可改变指针变量指向的数组元素值
** 2.int* const p						可改变指针变量指向的数组元素值，但不可改变指针变量值
** 3.const int * p					    可改变指针变量值，但不可改变指针变量指向的数组元素值
**
** 总结：const 在 * 之前，指针变量所指向的数组内元素值不可改变，指针变量值可以改变
**      const 在 * 之后，指针变量所指向的数组内元素值可改变，指针变量值不可改变
*/
```

>注：如下cpci变量，无论指针本省还是它所指向的值都是常量，都不允许修改。
```
int const   *   const cpci;
```

>#define 指令是另一种创建名字常量的机制，区别在于：#define定义的名字常量允许使用字面值常量的位置都可以使用，比如声明数组长度；但const变量只能用于允许使用变量值的地方。
使用#define可以提供程序的可维护性。


### 作用域
>标志符声明的位置决定它的作用域，编译器可以确认4种不同类型的作用域：
- 文件作用域  在代码块之外声明的标识符的作用域从其声明之处直到文件结尾处。
- 函数作用域
- 代码块作用域
- 原型作用域  在函数原型中声明的参数名可以省略。

### 链接属性
>标识符的链接属性决定如何处理在不同文件中出现的相同标识符。标识符的作用域于它的链接属性有关。
链接属性一共有3种：
- external 不同源文件中的多个声明都表示同一实体。(extern 缺省情况下为此类型。)
- internal 在同一源文件内的所有声明中的标志符都指向当前文件中的同一实体，不同源文件的多个声明则分属于不同的实体。(static,变量和函数仅在当前源文件内有效，其他文件内无法使用。)
- none  标识符的多个声明被当做独立的不同的实体

>extern用于某一标志符的第二次或以后的声明，无效。


### 存储类型
>变量的存储类型是指存储变量值的内存类型。变量的存储类型决定变量何时创建、何时销毁以及它的值将保持多久。有三个位置可用于存储变量：
- 普通内存
- 运行时堆栈
- 硬件寄存器

>变量的缺省存储类型取决于它的声明位置：
- 凡是在代码块之外声明的变量总是存储于静态内存中，这类变量被称为静态变量。
- 在代码块内声明的变量的缺省存储类型是auto.此类变量存储于堆栈中，称为自动变量。
- 在代码块内声明的变量，如果使用static修饰，可以使其存储类型从auto变为静态类型。static修饰仅改变代码块内变量的存储属性，不会改变其作用域。函数的形参不能声明为静态变量。
- 在代码块内声明的变量，如果使用register修饰，<em>提示（与编译器的寄存器优化策略有关，仅仅是建议，是否会被自动降级为auto,依赖于编译器优化）</em>此变量存放在机器的硬件寄存器中，这类变量称为寄存器变量，寄存器变量比存储于内存中的变量的访问效率高。


>一般情况下，把使用频率最高的变量声明为寄存器变量会提高程序运行效率。而在某些机器上，将指针声明为寄存器变量，程序效率也会得到提高。

>静态变量在程序加载时，如果没有指定初始化值，会自动赋予0,'\0'.

>自动变量没有缺省的初始值，所以如果不为自动变量指定初始化值，则该变量的值是不可预知的。

### static关键字
- 用于函数定义或者代码块外变量声明时，用于将函数或变量的链接属性由external修改为internal.
- 用于修改代码块内变量时，将自动变量修改为静态变量，但其链接属性和作用域不受影响。


## 语句
>C语言不具备专门的赋值语句，而是统一使用"表达式语句"代替。

## 操作符和表达式
>位操作符：& | ^

>移位操作：<< >>

>结构成员：.和->操作符用于访问一个结构的成员。若s是结构变量，则s.a就访问s中名为a的成员。
如果s是一个指向结构的指针，则使用s->a访问s指向的结构体重的a成员。


### 布尔值
>C并没有显式的布尔类型，所以用整数来代替。其规则是：
>>零是假，任何非零值皆为真。

### 左值与右值
>左值(L-value) 能够出现在赋值符号左边的语法元素。

>右值(R-value) 可以出现在赋值符号右边的语法元素。


### 表达式求值
#### 隐式类型转换
>表达式中的字符型和短整型操作数在使用之前都会被转换为普通整型(整型提升)。

#### 算数转换
>当参与运算的各个操作数属于不同的类型时，需要将其中一个操作数转换为另一个操作数。转换体系为<em>一般算术转换：</em>
```
long double
double
float
unsigned long int
long int
unsigned int
int
```
>若某个操作数的类型在上面列表中排名较低，那么它首先将转换为另外一个操作数的类型然后执行操作。

#### 操作符的属性
>复杂表达式的求值顺序是由3个因素决定的：
- 操作符的优先级
- 操作符的结合性
- 操作符是否控制执行的顺序

>两个相邻的操作符哪个先执行取决于它们的优先级，若两者优先级相同，那么它们的执行顺序由它们的结合性决定。

>结合性：一串操作符是从左向右依次执行还是从右向左逐个执行。


>有四个操作符可以对整个表达式的求值顺序进行控制：
- ,
- &&
- ||
- ?:


## 指针
### 内存和地址
>为了存储更大的值，许多机器以字为单位存储整数，每个字一般由2个或4个字节组成。
注：
- 尽管一个字包含了4个字节，它仍然只有一个地址；至于它的地址是它最左边的那个字节的位置还是最右边那个字节的位置，不同的机器有不同的规定。
- 边界对齐：在要求边界对齐的机器上，整型值存储的起始位置只能时某些特定的字节，通常是2或4的倍数。

>变量名与内存位置之间的关联并不是硬件所提供的，它是由编译器为我们提供的；硬件仍然通过地址访问内存位置。

>>同一内存中存储的值， 使用方式(解释方法)不同，得到的“值”不同。

### 指针变量初始化
>指针变量必须初始化，比如如下使用是错误的：
```c
int     *a;
...
*a = 12; //指针变量a并未初始化，就将12赋给a所指向的内存中，会导致异常。
```

### NULL 指针
>NULL指针不指向任何东西，是一个特殊的指针变量。

>对尚不确定指向的指针初始化为NULL,在使用指针前对指针是否为NULL进行判断。

>注：
```c
//*100 = 25;          //错误
*(int *)100 = 25;     //可用于使用确定地址访问硬件
```

### 指针的指针
>声明方式如下：
```
int     a = 12;
int     *b = &a;
int     **c = &b;
```
>关于左值和右值：
>>以赋值符号'='为界，'='左边的就是左值，'='右边的就是右值。

>>>左值是具有对应的可以由用户访问的存储单元，并且能够由用户去改变其值的量。左值表示存储在计算机内存的对象，而不是常量或计算的结果；或者说左值是代表一个内存地址值，并且通过这个内存地址，就可以对内存进行读并且写操作。


>>>右值代表真实值，可以是字面量或者变量(能够通过它读取真实值的量)。

>关于操作符的结核性：
>>结合性：一个操作数左右两边各有一个操作符时，先按照操作符的优先级决定运算次序，如果优先级相同，再按照操作符的结合性来决定运算次序。运算符的结合性决定了在操作数左右两侧操作符优先级相同时，先执行哪一侧的运算。
```c
// = 具有右结合性——表达式从右向左依次执行，所以先执行b=c,再执行a=b,所以a=2
int a,b=1,c=2;
a=b=c;
```

```c
char ch = 'a';
char *cp = &ch;
```

>常用表达式：
- ++cp 是非法左值
- cp++ 是非法左值
- *++cp 是合法的左值，同时也是合法的右值
- *cp++ ++操作符优先级高于\*操作符,++操作符先生成cp的一份拷贝，然后增加cp的值，使cp指向下一字节。最后\*操作符对++产生的cp拷贝执行间接访问操作
- ++*cp ++和\*的结合性都是从右向左，所以首先执行间接访问操作，然后cp所指向的位置的值增加1，表达式的结果是增值的的值的一份拷贝
- (*cp)++ 分析同上
- ++*++cp
- ++*cp++


### 指针运算
#### 算术运算
>C的指针算术运算只限于两种形式：
- 指针  +/-     整数    指向数组中某个元素的指针可以进行此操作，计算结果是指针
- 指针  -       指针    当两个指针指向同一个数组中的元素时，允许此操作；计算结果是一种有符号整数类型，表示两个指针在内存中的距离(以数组元素的长度为单位，而不是以字节为单位)。

#### 关系运算
>对指向同一数组中的元素的指针，可以进行如下关系运算：
- <
- <=
- >
- >=

>注意对比如下代码：
```c
for(vp = &values[N_VALUES];vp>&values[0]; )
    *--vp = 0;
//下面这种实现，在循环执行完毕之后，vp移动到了数组的第一个元素前面的'字节'.标准允许指向数组元素的指针与指向数组最后一个元素后面的那个内存未知的指针进行比较，但不允许与指向数组第一个元素之前的那个内存位置的指针进行比较。在编写可移植代码时尽量不要用如下实现。
for(vp = &values[N_VALUES-1];vp >= &values[0];vp--)
    *vp = 0;
```

## 函数
>使用函数原型的最简洁和最安全的方式是将函数原型置于一个单独的文件中，当其他源文件需要这个函数的原型时，就使用#include引用此文件即可。

>当程序调用一个没有原型的函数时，编译器便认为该函数返回一个整型值。对于不返回整型值的函数，会出现错误。

### 函数参数
>C中函数的所有参数均以"传值调用"方式进行传递，这意味着函数将获得参数值的一份拷贝，在函数内部修改这个拷贝值，不会影响实参值。但是如果所传递的参数是一个数组名(实际是一个指针，传递的是一个指针的拷贝)，则为"传址调用"。


### ADT 和 黑盒
>C语言可以限制函数和数据定义的作用域的特性可用于设计和实现ADT(抽象数据类型,abstract data type)。这个技巧称为黑盒设计。

### 递归
>C语言通过运行时堆栈支持递归函数的实现。递归函数就是直接或间接调用自身的函数。

>尾递归和迭代


### 可变参数列表
>可变参数列表通过宏来实现，这些宏定义在stdarg.h头文件中，它是标准库的一部分。此头文件生命了额一个类型va_list和三个宏——va_start、va_arg和va_end.

## 数组
>数组名是指针常量，不是指针变量。例外：
- 数组名作为sizeof操作符的操作数   返回整个数组的长度
- 数组名作为&的操作数 产生一个指向数组的指针
  
>除了优先级之外，下标引用和间接访问完全相同。

>在既可以使用下标又可以使用指针时，下标绝不会比指针更有效率，但指针有时会比下标更有效率。


>注：如何使用gcc生成汇编代码？
- 使用如下命令生成汇编代码：
  ```
  gcc -S  sum.c
  ```
  执行命令后会在源文件同一目录下生成sum.s的文件，此为汇编文件。直接使用文本编辑器打开即可。

>经验：
- 当根据某个固定数目的增量在一个数组中移动时，使用指针变量将比使用下标产生效率更高的代码。当这个增量是1并且机器具有地址自动增量模型时，这更明显。
- 声明为寄存器变量的指针通常比位于静态内存和堆栈中的指针效率更高。
- 若可以通过测试一些已经初始化并经过调整的内容来判断循环是否应该终止，就不要使用计数器。
- 必须在运行时求值的表达式比如&array[SIZE]或array+SIZE这样的常量表达式往往代码更高。

### 数组和指针
>指针和数组并不是相等的：
```c
int     a[5];
int     *b;
```
>>相同点：
- 都可以进行间接访问
- 都可以使用下标引用

>>不同点：
- 声明数组时，编译器为数组开辟空间；声明指针变量时，编译器仅仅为指针变量自身开辟空间，并不会为任何正性质分配内存空间。
- 声明数组时，数组名所指代的地址指向数组的第一个元素的地址；指针变量声明后，在未初始化之前，并未指向任何内存空间。
- 在声明后，\*a合法,指向数组第一个元素；\*b不合法，指向未知内存空间。
- b++ 合法，a++不合法。因为b是一个指针变量，而a是指针常量。
- sizeof(b)结果为指针变量所占内存大小；sizeof(a)为数组长度。
- &b合法，为指针变量b的地址。&a非法，因为a已经是地址。

>注：指针可以使用下标访问，b[i]会被编译器处理为：*(b+i)：
```c
int a = 10;
int *b = &a;
printf("变量a的值是：%d \n",b[0]);
printf("变量a的地址的下一字节是：%d \n",b[1]);
```

>当数组作为函数形参时，形参既可以为指针变量，也可以为数组；优先使用指针变量，因为本质上函数不会为数组形参开辟内存空间，它作为指针处理。
```c
int strlen(char *string);
int strlen(char string[]);
```
如果在函数中需要知道数组长度，需要使用函数形参传入。


>字符数组和字符串常量比对：
```c
char    message1[] = "Hello"; /* 声明并初始化一个字符数组 */
char    *message2  = "Hello"; /* 声明并初始化一个字符串常量 */
```

>C语言数组元素的存储顺序是行主序——多维数组的元素存储顺序按照最右边的下标率先变化的原则。


>在多维数组指针中，需要重视一个概念：<em>指向数组的指针</em>

>逗号运算符：, 会首先对第一个表达式求值，但随即丢失这个值；然后对第二个表达式求值，将这个值作为最终结果。

### 指向数组的指针
```c
int     vector[10], *vp = vecotr;
int     matrix[3][10];
//int     *mp = matrix;             /* 不合法，matrix是一个指向整型数组的指针，而不是一个指向整型的指针 */
int     (*p)[10] = matrix;              /* 合法，p为一个指向有10个整型元素的数组的指针 */
```

```c
/*
** 前两个指针指向二维数组matrix的第0行的第0个元素；增加这两个指针的值都** 可以使它们指向下一个整型元素。
**
** 而 第三个指针是指向一维数组，增加它的值会使指针指向多维数组的下一行。
*/
int     *pi =   &matrix[0][0];
int     *pi =   matrix[0];
int     *pi =   matrix;
```

>注：应该避免如下声明：
```c
int     (*p)[] = matrix; /* 此指针在增加时，它的值根据空数组的长度进行调整 */
```

>多维数组名作为函数形参时，需要标注第二维的长度。如：
```c
void func2(int (*mat)[10]);
void func2(int mat[][10]);
int matrix[3][10];
func2(matrix);
```

>在编写一维数组形参的函数原型时，形参既可以写成数组形式，也可以写成指针形式；但是对多维数组，只有第1维可以进行如此选择。如下原型时不正确的：
```c
void func2(int **mat);
```

>在多维数组中，只有第1维才能根据初始化列表缺省提供，剩余的几个维度必须显式地指出。

### 指针数组
>下标引用的优先级高于间接访问。如下指向整型的指针数组声明：
```c
int     *api[10];       //声明指向整型的指针数组
int     (*api)[10];     //声明指向整型数组的指针
```


>技巧：在使用指针数组存储字符串时，可以在表的末尾增加一个NULL指针,可以在遍历列表时使用当前元素是否等于NULL判断是否到列表末尾，而不用再传入数组大小：
```c
char       const    *keyword[] = {
            "do",
            "for",
            "if",
            "register",
            "return",
            "switch",
            "while",
             NULL
};

for(kwp = keyword_table;*kwp != NULL;kwp++)
```

## 字符串、字符和字节
>字符串长度不包含NUL字节。

>无符号数永远不可能为负，在表达式中使用无符号数或者同时包含了有符号数和无符号数都会导致一些问题：
```c
if(strlen(x) >= strlen(y)) ...
// 判断条件永远为真，因为strlen返回值为无符号整数，所以右侧表达式计算结果为无符号整数，永远大于等于0，所以判断条件永远为真。
if(strlen(x) - strlen(y) >= 0) ...
```

### 不受限制字符串
>字符串以NUL结尾的特性，所以称为不受限制。
- 复制字符串  
    - char  *strcpy(char *dst, char const *src);
      * 即使新字符串比dst原先的长度要小，由于新字符串是以NUL字节结尾，所以老字符串最后剩余的几个字符也会被删除。
      * 需要确保dst有足够空间容纳src
- 连接字符串   
    - char *strcat(char *dst,char const *src); 
        - 需要确保dst有足够空间容纳src
- 字符串比较    
    - int strcmp(char const *s1,char const *s2);
- 查找字符     
    - char *strchr(char const *str,int ch);
    - char *strchr(char const *str,int ch);
- 查找几个字符中的任一个   
    - char *strpbrk(char const *str,char const *group);
- 查找一个子串  
    - char *strstr(char const *s1,char const *s2);
- 查找一个字符串前缀  
    - size_t strspn(char const *str,char const *group);   
        - 对str从左向右依次扫描，返回第一个不再group字符集合中的字符的索引值。
    - size_t strcspn(char const *str,char const *group);  
        - 对str从左向右依次扫描，返回从开头开始，连续不包含group中字符的子串长度。

- 根据分隔符提取子串
    - char *strtok(char * str,char const * sep);
- 异常信息提示：char *strerror(int error_number);
- 单独字符处理函数包含在头文件<ctype.h>中。
- 能够操作任意的字节序列(与字符串处理函数不同，它们在遇到NUL字节时不会返回)，操作与字符串函数类似的函数：
    - void *memcpy(void *dst,void const *src,size_t length);
    - void *memmove(void *dst,void const *src,size_t length);
    - void *memcmp(void const *a,void const *b,size_t length);
    - void *memchr(void const *a,int ch,size_t length);
    - void *memset(void *a,int ch,size_t length);

>注：参数的类型是void\*型指针，任何类型的指针都可以转换为void\*型指针。
```c
memcpy(temp,values,sizeof(values));
memcpy(saved_answers,answers,count*sizeof(answer[0]));
```


## 结构和联合
>聚合数据类型如数组、结构体能够同时存储超过一个的单独数据。

>结构体与数组比较：
- 结构是一些值的集合，这些值可以有不同的数据类型，可以通过结构中成员的名字来访问它们。
- 在表达式中使用结构体名称时，它并不会替换为一个指针。结构变量无法使用下标来选择特定的成员。
- 结构变量属于标量类型，可以执行标量类型的一些操作。结构体也可以作为参数传递给函数，也可以作为函数返回值；相同类型的结构体变量之间可以互相赋值。
- 可以声明指向结构体的指针，获取一个结构体变量的地址，也可声明结构体数组。

### 结构声明
>结构声明格式如下：
```c
struct tag { member-list } variable-list;
```
>在结构体声明时可以使用typedef简化代码。如果有多个源文件中需要使用某个结构体，可以使用typedef声明后放入头文件中，需要使用的源文件直接引用此头文件即可。

>结构体成员可以是各种数据类型，比如：数组、指针、指针数组、结构体等。

### 结构成员的访问
>直接访问：结构变量的成员是通过点操作符(.)访问的：
```c
comp.sa[4].c
```
>间接访问：使用指向结构体的指针时，需要首先对指针进行间接访问操作——*操作，然后对结果进行直接访问即可：
```c
(*p).sa[4].c
```
>>简化访问：
```c
p -> c
```

### 结构体的自引用
>如下形式的自引用非法：
```c
struct  SELF_REF{ 
    int a;
    struct SELF_REF b;
}
```
但如下形式的自引用合法：
```c
//一般使用
struct SELF_REF{ 
    int a;
    struct SELF_REF *p;      /* 指针 */
};
//成功
typedef struct SELF_REF{ 
    int a;
    struct SELF_REF *p;      /* 指针 */
} SR;
//失败
typedef struct { 
    int a;
    struct SR *p;           /* 指针 */
} SR;
```

### 结构体的互相引用
>在声明互相引用的结构体时，需要采用与结构体自引用同样的策略：使用指针作为成员。为了解决哪个结构体先定义的问题，使用**不完整声明**：
```c
struct B;
sturct A {
    struct B *partner;
};

struct B { 
    struct A *partner;
};
```
### 结构的初始化
>结构体的初始化与数组的初始化很相似。

### 结构、指针和成员

### 结构的存储分配
>内存边界对齐：计算机要求基本数据类型在内存中存放时首地址的值是某个数k(通常为4或者8)的倍数。
>>在内存中存储结构时，编译器按照成员列表的顺序一个接一个地给每个成员分配内存。只有当存储成员时需要满足边界对齐要求时，成员之间才可能出现用于填充的额外内存空间。

>为什么有内存边界对齐要求：
>>处理器为了提高程序指令执行效率，需要尽可能减少读取命令的次数，为了尽可能一次能够读取一条命令，所以要求数据在内存中存储时，以结构体中占空间最大的数据类型存储，未存储数据的位空闲。这样就避免了在读取'在未对齐情况下跨边界'数据时进行数据读取的次数和对读取的数据进行拼接处理的过程，提高了程序执行效率。

>边界对齐规则：
- 编译器按照结构体成员列表顺序给每个成员分配内存
- 当成员需要满足正确的边界对齐时，成员之间额外字节填充
- 结构体的首地址必须满足结构体中边界对齐要求最为严格的数据类型所要求的首地址
- 结构体的大小为其最宽数据类型的整数倍


>注：关于边界对齐要求严格度：
>>计算机要求基本数据类型在内存中存放时首地址的值是某个数k(通常为4或者8)的倍数。k被称为数据类型的对齐模数。
>>>当一种类型S的对齐模数比另一种类型T的对齐模数的比值大于1时，就称类型S的对齐要求比T强(严格)，而称T的对齐要求比S弱(宽松)。

>sizeof操作符能够获取一个结构体的整体长度，包括因边界对齐而额外填充的字节。

>offsetof(type,member)宏可以求得成员在结构体内的偏移，返回size_t.

>\#pragma pack([show]|[push|pop][,identifier],n) 可以通知给编译器传递预编译指令而改变对指定数据的对齐方法


### 结构作为函数参数
>结构体变量是标量，所以它可以出现在任何标量可以出现的位置。
>>建议使用结构体指针作为函数参数，因为指针比结构体占内存小的多，在函数运行时，将结构体压栈效率会很低。


### 位段
>位段优点：
- 节省存储空间
- 可以很方便地访问一个整型值的部分内容

>位段的内存分配是由右向左。

>使用位段只是基于方便的目的，任何可以用位段实现的任务都可以使用移位和屏蔽来实现。

>使用位段的源码可移植性差，在使用时需要权衡。

### 联合体


## 动态内存分配
>使用动态内存分配的理由： 数组存储数据需要提前设定空间大小，缺乏灵活性，可能会造成空间浪费，或者无法存储超出预期的数据。

### malloc和free
>函数库提供了两个函数：malloc与free，分别执行动态内存分配和释放。

>malloc无法知晓分配的内存用于存储何种类型的数据，所以返回void*，void*类型的指针可以转换为其他任何类型的指针。

>对于要求边界对齐的机器，malloc所返回的内存的起始位置将始终能够满足对边界对齐要求最严格的类型的要求。

>若无法分配内存，malloc返回NULL。

>free参数必须是malloc、calloc、realloc返回的值。

## calloc 和 realloc
>calloc与realloc区别：
- calloc在返回指向内存的指针之前把它初始化为0.
- 它们请求内存数量的方式不同

>realloc函数用于修改一个原先已经分配的内存块的大小。通过此函数可以使内存扩大或缩小。如果原先的内存块无法改变大小，realloc将分配另一块正确大小的内存，并把原来那块内存的内容复制到新的块上，指向旧内存的指针不再可用，需要改用realloc返回的新指针。

>如果realloc函数的第一个参数是NULL，那么它的行为就和malloc一模一样。


### 常见的动态内存错误
- 对NULL指针进行解引用操作
- 对分配的内存进行操作时越界
- 释放并非动态分配的内存
- 试图释放一块动态分配的内存的一部分
- 动态内存被释放之后尝试继续使用

### 内存泄漏(memory leak)
>分配内存但在使用完毕后不释放将引起内存泄漏。


